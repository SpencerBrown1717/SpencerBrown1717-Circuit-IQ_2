import os
import math
import numpy as np
from PIL import Image, ImageDraw, ImageFont
from typing import Dict, List, Tuple, Any


class PCBVisualizer:
    """
    Creates a simple visualization of a PCB design for preview purposes.
    """
    
    def __init__(self, components, connections, board_params, placements=None):
        self.components = components
        self.connections = connections
        self.board_params = board_params
        self.placements = placements or {}
        
        # Colors for different PCB elements
        self.colors = {
            "board": (0, 100, 0),       # Dark green for the PCB board
            "copper": (184, 115, 51),   # Copper color
            "silkscreen": (255, 255, 255),  # White for silkscreen
            "background": (40, 40, 40), # Dark gray for background
            "traces": (204, 102, 0),    # Orange-copper for traces
            "pads": (224, 164, 88),     # Lighter copper for pads
            "resistor": (75, 87, 219),  # Blue for resistors
            "capacitor": (219, 75, 75),  # Red for capacitors
            "LED": (75, 219, 75),       # Green for LEDs
            "microcontroller": (219, 219, 75)  # Yellow for microcontrollers
        }
        
        # Calculate pixel scale based on board size
        self.scale = 5  # Pixels per mm
        self.width_px = int(self.board_params["width"] * self.scale)
        self.height_px = int(self.board_params["height"] * self.scale)
        self.padding = 20  # Pixels padding around the board
        
        # Calculate component placements if not provided
        if not self.placements:
            self._calculate_placements()
    
    def _calculate_placements(self):
        """Calculate component placements using a simple grid layout"""
        grid_size = int(math.ceil(math.sqrt(len(self.components))))
        cell_width = self.board_params["width"] / grid_size
        cell_height = self.board_params["height"] / grid_size
        
        for i, component in enumerate(self.components):
            row = i // grid_size
            col = i % grid_size
            
            # Center component in its cell
            x = col * cell_width + cell_width / 2
            y = row * cell_height + cell_height / 2
            
            # Component footprint size based on type (simplified)
            footprint_width = 10  # Default width in mm
            footprint_height = 5  # Default height in mm
            
            comp_type = component.get("type", "unknown")
            if comp_type == "resistor":
                footprint_width = 8
                footprint_height = 3
            elif comp_type == "capacitor":
                footprint_width = 6
                footprint_height = 6
            elif comp_type == "LED":
                footprint_width = 5
                footprint_height = 5
            elif comp_type == "microcontroller":
                footprint_width = 20
                footprint_height = 20
            
            # Calculate pin positions based on footprint
            pins = component.get("pins", 2)
            pin_positions = []
            
            if pins == 2:
                # Place pins at left and right edges
                pin_positions.append((x - footprint_width/2, y))  # Pin 1
                pin_positions.append((x + footprint_width/2, y))  # Pin 2
            elif pins <= 4:
                # Place pins at corners
                pin_positions.append((x - footprint_width/2, y - footprint_height/2))  # Pin 1
                pin_positions.append((x + footprint_width/2, y - footprint_height/2))  # Pin 2
                pin_positions.append((x + footprint_width/2, y + footprint_height/2))  # Pin 3
                pin_positions.append((x - footprint_width/2, y + footprint_height/2))  # Pin 4
            else:
                # Distribute pins around perimeter for larger components
                pins_per_side = pins // 4
                remaining_pins = pins % 4
                
                # Bottom side
                for p in range(pins_per_side):
                    pin_x = x - footprint_width/2 + p * (footprint_width / (pins_per_side - 1 or 1))
                    pin_positions.append((pin_x, y - footprint_height/2))
                
                # Right side
                for p in range(pins_per_side):
                    pin_y = y - footprint_height/2 + p * (footprint_height / (pins_per_side - 1 or 1))
                    pin_positions.append((x + footprint_width/2, pin_y))
                
                # Top side
                for p in range(pins_per_side):
                    pin_x = x + footprint_width/2 - p * (footprint_width / (pins_per_side - 1 or 1))
                    pin_positions.append((pin_x, y + footprint_height/2))
                
                # Left side
                for p in range(pins_per_side + remaining_pins):
                    pin_y = y + footprint_height/2 - p * (footprint_height / (pins_per_side - 1 or 1))
                    pin_positions.append((x - footprint_width/2, pin_y))
            
            # Store placement information
            self.placements[i] = {
                "x": x,
                "y": y,
                "width": footprint_width,
                "height": footprint_height,
                "pin_positions": pin_positions[:pins],  # Limit to actual number of pins
                "type": comp_type
            }
    
    def _mm_to_px(self, mm_x, mm_y):
        """Convert mm coordinates to pixel coordinates"""
        px_x = int(mm_x * self.scale) + self.padding
        px_y = int(mm_y * self.scale) + self.padding
        return px_x, px_y
    
    def render_pcb(self, output_path=None):
        """Render the PCB design as an image"""
        # Create image with padding
        img_width = self.width_px + 2 * self.padding
        img_height = self.height_px + 2 * self.padding
        img = Image.new('RGB', (img_width, img_height), self.colors["background"])
        draw = ImageDraw.Draw(img)
        
        # Draw PCB board
        board_coords = self._mm_to_px(0, 0) + self._mm_to_px(self.board_params["width"], self.board_params["height"])
        draw.rectangle(board_coords, fill=self.colors["board"])
        
        # Draw traces for connections
        for conn in self.connections:
            from_comp = conn.get("from", {}).get("component")
            from_pin = conn.get("from", {}).get("pin", 0)
            to_comp = conn.get("to", {}).get("component")
            to_pin = conn.get("to", {}).get("pin", 0)
            
            if (from_comp in self.placements and to_comp in self.placements and
                from_pin < len(self.placements[from_comp]["pin_positions"]) and
                to_pin < len(self.placements[to_comp]["pin_positions"])):
                
                from_x, from_y = self.placements[from_comp]["pin_positions"][from_pin]
                to_x, to_y = self.placements[to_comp]["pin_positions"][to_pin]
                
                # Convert to pixel coordinates
                from_px = self._mm_to_px(from_x, from_y)
                to_px = self._mm_to_px(to_x, to_y)
                
                # Draw trace line
                trace_width = max(1, int(self.board_params.get("trace_width", 0.25) * self.scale))
                draw.line([from_px, to_px], fill=self.colors["traces"], width=trace_width)
        
        # Draw components and pads
        for comp_id, placement in self.placements.items():
            # Draw component body
            comp_x, comp_y = placement["x"], placement["y"]
            comp_width, comp_height = placement["width"], placement["height"]
            
            x1, y1 = self._mm_to_px(comp_x - comp_width/2, comp_y - comp_height/2)
            x2, y2 = self._mm_to_px(comp_x + comp_width/2, comp_y + comp_height/2)
            
            comp_type = placement.get("type", "unknown")
            comp_color = self.colors.get(comp_type, self.colors["silkscreen"])
            
            # Draw component body
            draw.rectangle([x1, y1, x2, y2], fill=comp_color, outline=self.colors["silkscreen"])
            
            # Draw component label
            try:
                font = ImageFont.truetype("arial.ttf", 10)
            except IOError:
                font = ImageFont.load_default()
                
            label = comp_type.title()
            if len(label) > 15:
                label = label[:12] + "..."
                
            text_width = draw.textlength(label, font=font)
            text_x = (x1 + x2 - text_width) // 2
            text_y = (y1 + y2 - 10) // 2
            
            draw.text((text_x, text_y), label, fill=(0, 0, 0), font=font)
            
            # Draw pads
            for pin_x, pin_y in placement["pin_positions"]:
                px_x, px_y = self._mm_to_px(pin_x, pin_y)
                pad_size = max(2, int(0.8 * self.scale))  # Pad size in pixels
                draw.ellipse([px_x - pad_size, px_y - pad_size, px_x + pad_size, px_y + pad_size], 
                           fill=self.colors["pads"])
        
        # Draw board outline
        outline_coords = self._mm_to_px(0, 0) + self._mm_to_px(self.board_params["width"], self.board_params["height"])
        draw.rectangle(outline_coords, outline=self.colors["silkscreen"], width=2)
        
        # Save or return the image
        if output_path:
            img.save(output_path)
        
        return img
    
    def generate_3d_preview(self, output_path=None):
        """Generate a pseudo-3D preview of the PCB (simplified for MVP)"""
        # For now, we'll just create a 2D rendering with a slight perspective effect
        base_img = self.render_pcb()
        img_width, img_height = base_img.size
        
        # Create a new image for the 3D preview
        preview = Image.new('RGB', (img_width, img_height), self.colors["background"])
        preview.paste(base_img, (0, 0))
        
        # Add a simple shadow effect
        shadow = Image.new('RGBA', (img_width, img_height), (0, 0, 0, 0))
        shadow_draw = ImageDraw.Draw(shadow)
        
        board_coords = self._mm_to_px(0, 0) + self._mm_to_px(self.board_params["width"], self.board_params["height"])
        shadow_coords = (board_coords[0] + 10, board_coords[1] + 10, board_coords[2] + 10, board_coords[3] + 10)
        shadow_draw.rectangle(shadow_coords, fill=(0, 0, 0, 100))
        
        # Apply shadow
        preview = Image.alpha_composite(preview.convert('RGBA'), shadow).convert('RGB')
        
        # Add a title
        try:
            font = ImageFont.truetype("arial.ttf", 16)
        except IOError:
            font = ImageFont.load_default()
            
        draw = ImageDraw.Draw(preview)
        draw.text((self.padding, self.padding // 2), "AI-Generated PCB Design", 
                 fill=self.colors["silkscreen"], font=font)
        
        # Save or return the image
        if output_path:
            preview.save(output_path)
        
        return preview


# Example usage
if __name__ == "__main__":
    # Example components
    components = [
        {"type": "microcontroller", "pins": 8},
        {"type": "resistor", "pins": 2},
        {"type": "capacitor", "pins": 2},
        {"type": "LED", "pins": 2}
    ]
    
    # Example connections
    connections = [
        {"from": {"component": 0, "pin": 0}, "to": {"component": 1, "pin": 0}},
        {"from": {"component": 0, "pin": 1}, "to": {"component": 2, "pin": 0}},
        {"from": {"component": 0, "pin": 2}, "to": {"component": 3, "pin": 0}},
        {"from": {"component": 1, "pin": 1}, "to": {"component": 3, "pin": 1}}
    ]
    
    # Board parameters
    board_params = {
        "width": 100,
        "height": 80,
        "layers": 1,
        "trace_width": 0.25
    }
    
    # Generate visualization
    visualizer = PCBVisualizer(components, connections, board_params)
    
    # Save 2D and 3D previews
    visualizer.render_pcb("pcb_2d_preview.png")
    visualizer.generate_3d_preview("pcb_3d_preview.png")
    
    print("PCB visualization complete. Preview images saved.")
