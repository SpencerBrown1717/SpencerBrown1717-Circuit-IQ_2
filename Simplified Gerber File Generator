import os
import math
from typing import List, Dict, Tuple, Any

class SimpleGerber:
    """
    A simplified Gerber file generator for basic PCB designs.
    """
    
    def __init__(self):
        # Initialize with default settings
        self.apertures = {}
        self.next_aperture_id = 10
        self.current_aperture = None
        self.commands = []
    
    def _format_coord(self, value: float) -> str:
        """Format a coordinate value to 6-digit precision (Gerber format)"""
        # Gerber uses integer representation with implicit decimal point
        # We'll use 3 digits before and 3 after the decimal point
        value_int = int(value * 1000)
        return f"{value_int:06d}"
    
    def begin_file(self):
        """Initialize a new Gerber file"""
        self.commands = []
        self.apertures = {}
        self.current_aperture = None
        
        # Add Gerber file header
        self.commands.extend([
            "%FSLAX36Y36*%",  # Format specification: Leading zeros omitted, Absolute coords, 3.6 format
            "%MOMM*%",        # Units: Millimeters
            "%TF.GenerationSoftware,AI-PCB-Designer,1.0*%",
            "%TF.CreationDate,20240302*%",
            "%LPD*%"          # Layer Polarity: Dark
        ])
    
    def add_circle_aperture(self, diameter: float) -> int:
        """Define a circle aperture and return its ID"""
        aperture_id = self.next_aperture_id
        self.next_aperture_id += 1
        
        self.apertures[aperture_id] = f"%ADD{aperture_id}C,{diameter:.3f}*%"
        self.commands.append(self.apertures[aperture_id])
        
        return aperture_id
    
    def add_rectangle_aperture(self, width: float, height: float) -> int:
        """Define a rectangle aperture and return its ID"""
        aperture_id = self.next_aperture_id
        self.next_aperture_id += 1
        
        self.apertures[aperture_id] = f"%ADD{aperture_id}R,{width:.3f}X{height:.3f}*%"
        self.commands.append(self.apertures[aperture_id])
        
        return aperture_id
    
    def set_current_aperture(self, aperture_id: int):
        """Set the current aperture for drawing"""
        if aperture_id in self.apertures:
            self.current_aperture = aperture_id
            self.commands.append(f"D{aperture_id}*")
    
    def draw_line(self, x1: float, y1: float, x2: float, y2: float):
        """Draw a line from (x1,y1) to (x2,y2) with current aperture"""
        if self.current_aperture is None:
            raise ValueError("No current aperture selected")
            
        # Move to start point
        self.commands.append(f"X{self._format_coord(x1)}Y{self._format_coord(y1)}D02*")
        # Draw line to end point
        self.commands.append(f"X{self._format_coord(x2)}Y{self._format_coord(y2)}D01*")
    
    def draw_pad(self, x: float, y: float):
        """Draw a pad (flash) at position (x,y) with current aperture"""
        if self.current_aperture is None:
            raise ValueError("No current aperture selected")
            
        self.commands.append(f"X{self._format_coord(x)}Y{self._format_coord(y)}D03*")
    
    def draw_polygon(self, points: List[Tuple[float, float]]):
        """Draw a polygon defined by a list of points"""
        if not points or len(points) < 3:
            return
            
        if self.current_aperture is None:
            raise ValueError("No current aperture selected")
            
        # Move to first point
        x, y = points[0]
        self.commands.append(f"X{self._format_coord(x)}Y{self._format_coord(y)}D02*")
        
        # Draw lines to subsequent points
        for x, y in points[1:]:
            self.commands.append(f"X{self._format_coord(x)}Y{self._format_coord(y)}D01*")
            
        # Close the polygon by drawing back to the first point
        x, y = points[0]
        self.commands.append(f"X{self._format_coord(x)}Y{self._format_coord(y)}D01*")
    
    def draw_circle(self, x: float, y: float, radius: float, segments: int = 36):
        """Draw a circle using line segments"""
        points = []
        for i in range(segments):
            angle = 2 * math.pi * i / segments
            point_x = x + radius * math.cos(angle)
            point_y = y + radius * math.sin(angle)
            points.append((point_x, point_y))
            
        self.draw_polygon(points)
    
    def draw_rectangle(self, x: float, y: float, width: float, height: float):
        """Draw a rectangle with bottom-left corner at (x,y)"""
        points = [
            (x, y),
            (x + width, y),
            (x + width, y + height),
            (x, y + height)
        ]
        self.draw_polygon(points)
    
    def end_file(self):
        """Finish the Gerber file with appropriate footer"""
        self.commands.append("M02*")  # End of file
    
    def export_to_file(self, filename: str):
        """Export the Gerber commands to a file"""
        with open(filename, 'w') as f:
            for cmd in self.commands:
                f.write(cmd + '\n')
    
    def get_content(self) -> str:
        """Get the Gerber file content as a string"""
        return '\n'.join(self.commands)


class GerberGenerator:
    """
    Generates Gerber files for a complete PCB design.
    """
    
    def __init__(self, components, connections, board_params):
        self.components = components
        self.connections = connections
        self.board_params = board_params
        self.output_dir = None
        
        # Component placement information (will be calculated)
        self.placements = {}
    
    def place_components(self):
        """Place components on the board using a simple grid layout"""
        grid_size = int(math.ceil(math.sqrt(len(self.components))))
        cell_width = self.board_params["width"] / grid_size
        cell_height = self.board_params["height"] / grid_size
        
        for i, component in enumerate(self.components):
            row = i // grid_size
            col = i % grid_size
            
            # Center component in its cell
            x = col * cell_width + cell_width / 2
            y = row * cell_height + cell_height / 2
            
            # Component footprint size based on type (simplified)
            footprint_width = 10  # Default width in mm
            footprint_height = 5  # Default height in mm
            
            comp_type = component.get("type", "unknown")
            if comp_type == "resistor":
                footprint_width = 8
                footprint_height = 3
            elif comp_type == "capacitor":
                footprint_width = 6
                footprint_height = 6
            elif comp_type == "LED":
                footprint_width = 5
                footprint_height = 5
            elif comp_type == "microcontroller":
                footprint_width = 20
                footprint_height = 20
            
            # Calculate pin positions based on footprint
            pins = component.get("pins", 2)
            pin_positions = []
            
            if pins == 2:
                # Place pins at left and right edges
                pin_positions.append((x - footprint_width/2, y))  # Pin 1
                pin_positions.append((x + footprint_width/2, y))  # Pin 2
            elif pins <= 4:
                # Place pins at corners
                pin_positions.append((x - footprint_width/2, y - footprint_height/2))  # Pin 1
                pin_positions.append((x + footprint_width/2, y - footprint_height/2))  # Pin 2
                pin_positions.append((x + footprint_width/2, y + footprint_height/2))  # Pin 3
                pin_positions.append((x - footprint_width/2, y + footprint_height/2))  # Pin 4
            else:
                # Distribute pins around perimeter for larger components
                pins_per_side = pins // 4
                remaining_pins = pins % 4
                
                # Bottom side
                for p in range(pins_per_side):
                    pin_x = x - footprint_width/2 + p * (footprint_width / (pins_per_side - 1))
                    pin_positions.append((pin_x, y - footprint_height/2))
                
                # Right side
                for p in range(pins_per_side):
                    pin_y = y - footprint_height/2 + p * (footprint_height / (pins_per_side - 1))
                    pin_positions.append((x + footprint_width/2, pin_y))
                
                # Top side
                for p in range(pins_per_side):
                    pin_x = x + footprint_width/2 - p * (footprint_width / (pins_per_side - 1))
                    pin_positions.append((pin_x, y + footprint_height/2))
                
                # Left side
                for p in range(pins_per_side + remaining_pins):
                    pin_y = y + footprint_height/2 - p * (footprint_height / (pins_per_side - 1))
                    pin_positions.append((x - footprint_width/2, pin_y))
            
            # Store placement information
            self.placements[i] = {
                "x": x,
                "y": y,
                "width": footprint_width,
                "height": footprint_height,
                "pin_positions": pin_positions[:pins]  # Limit to actual number of pins
            }
    
    def generate_copper_layer(self, filename: str):
        """Generate the copper layer Gerber file"""
        gerb = SimpleGerber()
        gerb.begin_file()
        
        # Add apertures for traces and pads
        trace_ap = gerb.add_circle_aperture(self.board_params.get("trace_width", 0.25))
        pad_ap = gerb.add_circle_aperture(1.0)  # Pad size
        
        # Draw component pads
        gerb.set_current_aperture(pad_ap)
        for comp_id, placement in self.placements.items():
            for pin_pos in placement["pin_positions"]:
                gerb.draw_pad(*pin_pos)
        
        # Draw traces for connections
        gerb.set_current_aperture(trace_ap)
        for conn in self.connections:
            from_comp = conn.get("from", {}).get("component")
            from_pin = conn.get("from", {}).get("pin", 0)
            to_comp = conn.get("to", {}).get("component")
            to_pin = conn.get("to", {}).get("pin", 0)
            
            if (from_comp in self.placements and to_comp in self.placements and
                from_pin < len(self.placements[from_comp]["pin_positions"]) and
                to_pin < len(self.placements[to_comp]["pin_positions"])):
                
                from_pos = self.placements[from_comp]["pin_positions"][from_pin]
                to_pos = self.placements[to_comp]["pin_positions"][to_pin]
                
                # For simplicity, we'll draw a direct line for the MVP
                gerb.draw_line(*from_pos, *to_pos)
        
        gerb.end_file()
        gerb.export_to_file(filename)
        return gerb.get_content()
    
    def generate_mask_layer(self, filename: str):
        """Generate the solder mask layer Gerber file"""
        gerb = SimpleGerber()
        gerb.begin_file()
        
        # Slightly larger aperture for solder mask openings
        mask_ap = gerb.add_circle_aperture(1.2)  # Slightly larger than pad
        gerb.set_current_aperture(mask_ap)
        
        # Draw mask openings for pads
        for comp_id, placement in self.placements.items():
            for pin_pos in placement["pin_positions"]:
                gerb.draw_pad(*pin_pos)
        
        gerb.end_file()
        gerb.export_to_file(filename)
        return gerb.get_content()
    
    def generate_silkscreen_layer(self, filename: str):
        """Generate the silkscreen layer Gerber file"""
        gerb = SimpleGerber()
        gerb.begin_file()
        
        # Aperture for silkscreen lines
        silk_ap = gerb.add_circle_aperture(0.15)
        gerb.set_current_aperture(silk_ap)
        
        # Draw component outlines on silkscreen
        for comp_id, placement in self.placements.items():
            x, y = placement["x"], placement["y"]
            width, height = placement["width"], placement["height"]
            
            # Draw rectangle around component
            gerb.draw_rectangle(x - width/2, y - height/2, width, height)
            
            # Add a polarity marker near pin 1
            if len(placement["pin_positions"]) > 0:
                pin1_x, pin1_y = placement["pin_positions"][0]
                marker_size = min(width, height) * 0.2
                
                # Draw a small circle near pin 1
                offset_x = (pin1_x - x) * 0.1
                offset_y = (pin1_y - y) * 0.1
                gerb.draw_circle(pin1_x + offset_x, pin1_y + offset_y, marker_size / 2)
        
        gerb.end_file()
        gerb.export_to_file(filename)
        return gerb.get_content()
    
    def generate_edge_cuts_layer(self, filename: str):
        """Generate the board outline (edge cuts) Gerber file"""
        gerb = SimpleGerber()
        gerb.begin_file()
        
        # Aperture for edge cuts
        edge_ap = gerb.add_circle_aperture(0.1)
        gerb.set_current_aperture(edge_ap)
        
        # Draw board outline
        width = self.board_params["width"]
        height = self.board_params["height"]
        
        gerb.draw_rectangle(0, 0, width, height)
        
        gerb.end_file()
        gerb.export_to_file(filename)
        return gerb.get_content()
    
    def generate_drill_file(self, filename: str):
        """Generate Excellon drill file"""
        # Simple Excellon format drill file
        drill_content = [
            "M48",
            "FMAT,2",
            "METRIC,TZ",
            "T1C0.8",  # 0.8mm drill for component pads
            "%",
            "T1",
        ]
        
        # Add drill locations for each pad
        for comp_id, placement in self.placements.items():
            for pin_x, pin_y in placement["pin_positions"]:
                # Format coordinates for Excellon (mm)
                x_str = f"{pin_x:.3f}"
                y_str = f"{pin_y:.3f}"
                drill_content.append(f"X{x_str}Y{y_str}")
        
        drill_content.append("M30")
        
        # Write to file
        with open(filename, 'w') as f:
            f.write('\n'.join(drill_content))
    
    def generate_all_files(self, output_dir: str):
        """Generate all Gerber files for the PCB design"""
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
        
        # First, calculate component placements
        self.place_components()
        
        # Generate top copper layer
        top_copper_path = os.path.join(output_dir, "F_Cu.gbr")
        self.generate_copper_layer(top_copper_path)
        
        # Generate bottom copper layer if 2-layer board
        if self.board_params.get("layers", 1) > 1:
            bottom_copper_path = os.path.join(output_dir, "B_Cu.gbr")
            self.generate_copper_layer(bottom_copper_path)
        
        # Generate solder mask layer
        mask_path = os.path.join(output_dir, "F_Mask.gbr")
        self.generate_mask_layer(mask_path)
        
        # Generate silkscreen layer
        silk_path = os.path.join(output_dir, "F_SilkS.gbr")
        self.generate_silkscreen_layer(silk_path)
        
        # Generate edge cuts layer
        edge_path = os.path.join(output_dir, "Edge_Cuts.gbr")
        self.generate_edge_cuts_layer(edge_path)
        
        # Generate drill file
        drill_path = os.path.join(output_dir, "drill.drl")
        self.generate_drill_file(drill_path)
        
        return {
            "top_copper": top_copper_path,
            "mask": mask_path,
            "silkscreen": silk_path,
            "edge_cuts": edge_path,
            "drill": drill_path
        }


# Example usage
if __name__ == "__main__":
    # Example components
    components = [
        {"type": "microcontroller", "pins": 8},
        {"type": "resistor", "pins": 2},
        {"type": "capacitor", "pins": 2},
        {"type": "LED", "pins": 2}
    ]
    
    # Example connections
    connections = [
        {"from": {"component": 0, "pin": 0}, "to": {"component": 1, "pin": 0}},
        {"from": {"component": 0, "pin": 1}, "to": {"component": 2, "pin": 0}},
        {"from": {"component": 0, "pin": 2}, "to": {"component": 3, "pin": 0}},
        {"from": {"component": 1, "pin": 1}, "to": {"component": 3, "pin": 1}}
    ]
    
    # Board parameters
    board_params = {
        "width": 100,
        "height": 80,
        "layers": 1,
        "trace_width": 0.25
    }
    
    # Generate Gerber files
    generator = GerberGenerator(components, connections, board_params)
    output_dir = "example_output"
    generator.generate_all_files(output_dir)
    
    print(f"Gerber files generated in {output_dir} directory")
